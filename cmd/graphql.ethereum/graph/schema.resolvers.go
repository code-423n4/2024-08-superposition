package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"errors"
	"fmt"
	"math/big"
	"strconv"
	"time"

	"github.com/fluidity-money/long.so/cmd/graphql.ethereum/graph/model"
	graphErc20 "github.com/fluidity-money/long.so/cmd/graphql.ethereum/lib/erc20"
	"github.com/fluidity-money/long.so/lib/config"
	"github.com/fluidity-money/long.so/lib/events/thirdweb"
	"github.com/fluidity-money/long.so/lib/features"
	"github.com/fluidity-money/long.so/lib/math"
	"github.com/fluidity-money/long.so/lib/types"
	"github.com/fluidity-money/long.so/lib/types/erc20"
	"github.com/fluidity-money/long.so/lib/types/seawater"
	"gorm.io/gorm"
)

// Token is the resolver for the token field.
func (r *amountResolver) Token(ctx context.Context, obj *model.Amount) (model.Token, error) {
	if obj == nil {
		return model.Token{}, fmt.Errorf("empty amount")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		return MockToken(obj.Token.String())
	}
	var token erc20.Erc20
	err := r.DB.Table("erc20_cache_1").
		Where("address = ?", obj.Token).
		First(&token).
		Error
	switch {
	case err == nil:
		// Nothing went wrong! Return the user what we found.
		return model.Token{token}, nil
	case errors.Is(err, gorm.ErrRecordNotFound):
		// Look up the token, and store it in the database.
		name, symbol, totalSupply, err := graphErc20.GetErc20Details(
			ctx,
			r.Geth,
			obj.Token,
		)
		if err != nil {
			return model.Token{}, fmt.Errorf("erc20 token %#v: %v", obj.Token, err)
		}
		err = r.DB.Exec(
			"SELECT erc20_insert_1(?, ?, ?, ?, ?)",
			obj.Token,
			name,
			symbol,
			totalSupply,
			obj.Decimals,
		).
			Error
		if err != nil {
			return model.Token{}, fmt.Errorf("insert erc20 %v: %v", obj.Token, err)
		}
		return model.Token{erc20.Erc20{
			Address:     obj.Token,
			Name:        name,
			Symbol:      symbol,
			TotalSupply: totalSupply,
			Decimals:    obj.Decimals,
		}}, nil
	default:
		return model.Token{}, err
	}
}

// ValueUnscaled is the resolver for the valueUnscaled field.
func (r *amountResolver) ValueUnscaled(ctx context.Context, obj *model.Amount) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("amount empty")
	}
	return obj.ValueUnscaled.String(), nil
}

// ValueScaled is the resolver for the valueScaled field.
func (r *amountResolver) ValueScaled(ctx context.Context, obj *model.Amount) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty amount")
	}
	amt := obj.ValueUnscaled
	return amt.ScaleStr(obj.Decimals), nil
}

// ValueUsd is the resolver for the valueUsd field.
func (r *amountResolver) ValueUsd(ctx context.Context, obj *model.Amount) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty amount")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		// If we're mocking the graph, then we take the uncaled
		// amount, and we simply divide it by 1e6, then we divide
		// it by 0.04 unless the token is fUSDC.
		value := obj.ValueUnscaled
		dividedAmt := value.Scale(obj.Decimals) //value / (10 ** decimals)
		switch obj.Token {
		case r.C.FusdcAddr:
			// 4 decimals
			return fmt.Sprintf("%0.8f", dividedAmt), nil
		default:
			//value / (10 ** decimals) * 0.04
			x := new(big.Float).Set(dividedAmt)
			x.Quo(dividedAmt, new(big.Float).SetFloat64(0.04))
			return fmt.Sprintf("%0.8f", x), nil
		}
	}
	if obj.ValueUnscaled.Cmp(types.EmptyUnscaledNumber().Int) == 0 {
		return "0", nil
	}
	// If the pool is the fUSDC address, then we can just skip the
	// lookup here and report $1 (assuming we maintain the peg.)
	if obj.Token == r.C.FusdcAddr {
		return obj.ValueUnscaled.ScaleStr(5), nil
	}
	// Use the final tick function to get the row.
	var finalTick struct {
		FinalTick types.Number
	}
	err := r.DB.Table("seawater_latest_ticks_2").
		Select("final_tick").
		Where("pool = ?", obj.Token).
		First(&finalTick).
		Error
	if err != nil {
		return "", err
	}
	sqrtPrice := math.GetSqrtRatioAtTick(finalTick.FinalTick.Big())
	price := math.GetPriceAtSqrtRatio(sqrtPrice)

	// amount * price / (10 ^ fusdcDecimals)
	decimals := math.ExponentiateDecimals(int64(r.C.FusdcDecimals))
	valueScaled := new(big.Rat).SetInt(obj.ValueUnscaled.Int)
	value := valueScaled.Quo(valueScaled, decimals)
	price.Mul(price, value)

	return price.FloatString(5), nil
}

// CampaignID is the resolver for the campaignId field.
func (r *liquidityCampaignResolver) CampaignID(ctx context.Context, obj *model.LiquidityCampaign) (string, error) {
	panic(fmt.Errorf("not implemented: CampaignID - campaignId"))
}

// Owner is the resolver for the owner field.
func (r *liquidityCampaignResolver) Owner(ctx context.Context, obj *model.LiquidityCampaign) (model.SeawaterPositionsUser, error) {
	panic(fmt.Errorf("not implemented: Owner - owner"))
}

// PerSecond is the resolver for the perSecond field.
func (r *liquidityCampaignResolver) PerSecond(ctx context.Context, obj *model.LiquidityCampaign) (model.Amount, error) {
	panic(fmt.Errorf("not implemented: PerSecond - perSecond"))
}

// MaximumAmount is the resolver for the maximumAmount field.
func (r *liquidityCampaignResolver) MaximumAmount(ctx context.Context, obj *model.LiquidityCampaign) (model.Amount, error) {
	panic(fmt.Errorf("not implemented: MaximumAmount - maximumAmount"))
}

// FromTimestamp is the resolver for the fromTimestamp field.
func (r *liquidityCampaignResolver) FromTimestamp(ctx context.Context, obj *model.LiquidityCampaign) (int, error) {
	panic(fmt.Errorf("not implemented: FromTimestamp - fromTimestamp"))
}

// EndTimestamp is the resolver for the endTimestamp field.
func (r *liquidityCampaignResolver) EndTimestamp(ctx context.Context, obj *model.LiquidityCampaign) (int, error) {
	panic(fmt.Errorf("not implemented: EndTimestamp - endTimestamp"))
}

// Pool is the resolver for the pool field.
func (r *liquidityCampaignResolver) Pool(ctx context.Context, obj *model.LiquidityCampaign) (seawater.Pool, error) {
	panic(fmt.Errorf("not implemented: Pool - pool"))
}

// Served is the resolver for the served field.
func (r *queryResolver) Served(ctx context.Context) (model.Served, error) {
	return model.Served{
		Timestamp: int(time.Now().Unix()),
	}, nil
}

// Fusdc is the resolver for the fusdc field.
func (r *queryResolver) Fusdc(ctx context.Context) (t model.Token, err error) {
	return model.Token{erc20.Erc20{
		Address:     r.C.FusdcAddr,
		Name:        r.C.FusdcName,
		Symbol:      r.C.FusdcSymbol,
		TotalSupply: r.C.FusdcTotalSupply,
		Decimals:    r.C.FusdcDecimals,
	}}, nil
}

// Pools is the resolver for the pools field.
func (r *queryResolver) Pools(ctx context.Context) (pools []seawater.Pool, err error) {
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		pools = MockSeawaterPools()
		return
	}
	err = r.DB.Table("events_seawater_newpool").Scan(&pools).Error
	return
}

// ActiveLiquidityCampaigns is the resolver for the activeLiquidityCampaigns field.
func (r *queryResolver) ActiveLiquidityCampaigns(ctx context.Context) (campaigns []model.LiquidityCampaign, err error) {
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		campaigns = MockCampaigns()
		return
	}
	// TODO
	//err = r.DB.Table("leo_active_campaigns_1").Scan(&campaigns).Error
	return
}

// UpcomingLiquidityCampaigns is the resolver for the upcomingLiquidityCampaigns field.
func (r *queryResolver) UpcomingLiquidityCampaigns(ctx context.Context) (campaigns []model.LiquidityCampaign, err error) {
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		campaigns = MockCampaigns()
		return
	}
	// TODO
	//err = r.DB.Table("leo_upcoming_campaigns_1").Scan(&campaigns).Error
	return
}

// GetPool is the resolver for the getPool field.
func (r *queryResolver) GetPool(ctx context.Context, token string) (pool *seawater.Pool, err error) {
	tokenAddress := types.AddressFromString(token)
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		pool = MockGetPool(tokenAddress.String())
		return
	}
	err = r.DB.Table("events_seawater_newpool").
		Where("token = ?", tokenAddress).
		Scan(&pool).
		Error
	return
}

// GetPoolPositions is the resolver for the getPoolPositions field.
func (r *queryResolver) GetPoolPositions(ctx context.Context, pool string, first *int, after *int) (positions model.SeawaterPositionsGlobal, err error) {
	p := types.AddressFromString(pool)
	// If the user didn't set pagination, or they exceeded the restriction on the limit.
	if first == nil || *first > PoolPositionsPageSize {
		x := PoolPositionsPageSize
		first = &x
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		positions = model.SeawaterPositionsGlobal(MockGetPoolPositions(p))
		return
	}
	stmt := r.DB.Table("seawater_active_positions_2").
		Where("pool = ?", p).
		Limit(*first).
		Order("created_by desc")
	if after != nil {
		stmt = stmt.Where("pos_id > ?", *after)
	}
	var pos []seawater.Position
	if err := stmt.Scan(&pos).Error; err != nil || pos == nil {
		return positions, err
	}
	// If we actually got return data here, we want to set it so we
	// can start to paginate.
	var to *int
	if l := len(pos); l > 0 {
		x := int(pos[l-1].CreatedBy.Unix())
		to = &x
	}
	positions = model.SeawaterPositionsGlobal(model.SeawaterPositions{
		From:      *first,
		To:        to,
		Pool:      &p,
		Positions: pos,
	})
	return
}

// GetPosition is the resolver for the getPosition field.
func (r *queryResolver) GetPosition(ctx context.Context, id int) (position *seawater.Position, err error) {
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		position = MockGetPosition(id)
		return
	}
	err = r.DB.Table("seawater_positions_1").
		Where("pos_id = ?", id).
		Scan(&position).
		Error
	return
}

// GetPositions is the resolver for the getPositions field.
func (r *queryResolver) GetPositions(ctx context.Context, wallet string, first *int, after *int) (positions model.SeawaterPositionsUser, err error) {
	w := types.AddressFromString(wallet)
	// If the user didn't set the limit, or they requested too much.
	if first == nil || *first > PoolPositionsPageSize {
		x := PoolPositionsPageSize
		first = &x
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		positions = model.SeawaterPositionsUser(
			MockGetPoolPositions("0x65dfe41220c438bf069bbce9eb66b087fe65db36"),
		)
		return
	}
	stmt := r.DB.Table("seawater_active_positions_2").
		Where("owner = ?", w).
		Limit(*first).
		Order("created_by desc")
	if after != nil {
		stmt = stmt.Where("pos_id < ?", *after)
	}
	var pos []seawater.Position
	if err := stmt.Scan(&pos).Error; err != nil || pos == nil {
		return positions, err
	}
	id := pos[len(pos)-1].Id
	positions = model.SeawaterPositionsUser(model.SeawaterPositions{
		From:      pos[0].Id,
		To:        &id,
		Wallet:    &w,
		Positions: pos,
	})
	return
}

// GetWallet is the resolver for the getWallet field.
func (r *queryResolver) GetWallet(ctx context.Context, address string) (wallet *model.Wallet, err error) {
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		return &model.Wallet{Address: types.AddressFromString(address)}, nil
	}
	wallet = &model.Wallet{
		Address: types.AddressFromString(address),
	}
	return
}

// GetSwaps is the resolver for the getSwaps field.
func (r *queryResolver) GetSwaps(ctx context.Context, pool string, first *int, after *int) (swaps model.GetSwaps, err error) {
	poolAddress := types.AddressFromString(pool)
	// If there was no first supplied, or they went past the limit on pages.
	if first == nil || *first > SwapPositionsPageSize {
		fst := SwapPositionsPageSize
		first = &fst
	}
	if after == nil {
		aft := 0
		after = &aft
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		d := MockSwaps(r.C.FusdcAddr, 150, "0x65dfe41220c438bf069bbce9eb66b087fe65db36")
		return model.GetSwaps{d}, nil
	}
	var d []model.SeawaterSwap
	// DB.RAW doesn't support chaining
	err = r.DB.Raw(
		"SELECT * FROM seawater_swaps_pool_2(?, ?, ?, ?, ?)",
		r.C.FusdcAddr,
		r.C.FusdcDecimals,
		poolAddress,
		time.Unix(int64(*after), 0),
		*first,
	).
		Scan(&d).
		Error
	if err != nil {
		return
	}
	// If we actually got return data here, we want to set it so we
	// can start to paginate.
	var to int
	if l := len(d); l > 0 {
		to = int(d[l-1].CreatedBy.Unix())
	}
	swaps.Data = model.SeawaterSwaps{
		From:  *first,
		To:    to,
		Pool:  &poolAddress,
		Swaps: d,
	}
	return
}

// GetSwapsForUser is the resolver for the getSwapsForUser field.
func (r *queryResolver) GetSwapsForUser(ctx context.Context, wallet string, first *int, after *int) (swaps model.GetSwapsForUser, err error) {
	walletAddress := types.AddressFromString(wallet)
	// If the user requested too large a limit, or they didn't supply anything.
	if first == nil || *first > PoolPositionsPageSize {
		x := PoolPositionsPageSize
		first = &x
	}
	if after == nil {
		aft := 0
		after = &aft
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		d := MockSwaps(r.C.FusdcAddr, 150, walletAddress)
		return model.GetSwapsForUser{d}, nil
	}
	var d []model.SeawaterSwap
	// DB.RAW doesn't support chaining
	err = r.DB.Raw(
		"SELECT * FROM seawater_swaps_user_2(?, ?, ?, ?, ?)",
		r.C.FusdcAddr,
		r.C.FusdcDecimals,
		walletAddress,
		time.Unix(int64(*after), 0),
		*first,
	).
		Scan(&d).
		Error
	if err != nil {
		return
	}
	// If we actually got return data here, we want to set it so we
	// can start to paginate.
	var to int
	if l := len(d); l > 0 {
		to = int(d[l-1].CreatedBy.Unix())
	}
	swaps.Data = model.SeawaterSwaps{
		From:   *first,
		To:     to,
		Wallet: &walletAddress,
		Swaps:  d,
	}
	return
}

// GetSmartAccount is the resolver for the getSmartAccount field.
func (r *queryResolver) GetSmartAccount(ctx context.Context, wallet string) ([]model.Wallet, error) {
	if wallet == "" {
		return nil, fmt.Errorf("empty wallet")
	}
	var accountCreations []thirdweb.AccountCreated
	err := r.DB.Table("events_thirdweb_accountcreated").
		Where("account_admin = ?", wallet).
		Scan(&accountCreations).
		Error
	if err != nil {
		return nil, err
	}
	wallets := make([]model.Wallet, len(accountCreations))
	for i, a := range accountCreations {
		wallets[i] = model.Wallet{
			Address: a.Account,
		}
	}
	return wallets, nil
}

// ID is the resolver for the id field.
func (r *seawaterConfigResolver) ID(ctx context.Context, obj *model.SeawaterConfig) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty config")
	}
	return "config:" + obj.Addr.String(), nil
}

// Pool is the resolver for the pool field.
func (r *seawaterConfigResolver) Pool(ctx context.Context, obj *model.SeawaterConfig) (pool seawater.Pool, err error) {
	if obj == nil {
		return pool, fmt.Errorf("empty config")
	}
	err = r.DB.Table("events_seawater_newpool").
		Where("token = ?", obj.Addr).
		Scan(&pool).
		Error
	return
}

// TickLower is the resolver for the tickLower field.
func (r *seawaterLiquidityResolver) TickLower(ctx context.Context, obj *model.SeawaterLiquidity) (tick int, err error) {
	if obj == nil {
		return 0, fmt.Errorf("no pool obj")
	}
	tick, err = strconv.Atoi(obj.TickLower)
	return
}

// TickUpper is the resolver for the tickUpper field.
func (r *seawaterLiquidityResolver) TickUpper(ctx context.Context, obj *model.SeawaterLiquidity) (tick int, err error) {
	if obj == nil {
		return 0, fmt.Errorf("no pool obj")
	}
	tick, err = strconv.Atoi(obj.TickUpper)
	return
}

// Served is the resolver for the served field.
func (r *seawaterPoolResolver) Served(ctx context.Context, obj *seawater.Pool) (model.Served, error) {
	return model.Served{
		Timestamp: int(time.Now().Unix()),
	}, nil
}

// ID is the resolver for the id field.
func (r *seawaterPoolResolver) ID(ctx context.Context, obj *seawater.Pool) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty pool")
	}
	return obj.Token.String(), nil
}

// Fee is the resolver for the fee field.
func (r *seawaterPoolResolver) Fee(ctx context.Context, obj *seawater.Pool) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("no pool obj")
	}
	return int(obj.Fee.Int64()), nil
}

// Address is the resolver for the address field.
func (r *seawaterPoolResolver) Address(ctx context.Context, obj *seawater.Pool) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("no pool obj")
	}
	return obj.Token.String(), nil
}

// TickSpacing is the resolver for the tickSpacing field.
func (r *seawaterPoolResolver) TickSpacing(ctx context.Context, obj *seawater.Pool) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("no pool obj")
	}
	return strconv.Itoa(int(obj.TickSpacing)), nil
}

// Token is the resolver for the token field.
func (r *seawaterPoolResolver) Token(ctx context.Context, obj *seawater.Pool) (t model.Token, err error) {
	if obj == nil {
		return model.Token{}, fmt.Errorf("empty amount")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		return MockToken(obj.Token.String())
	}
	var token erc20.Erc20
	err = r.DB.Table("erc20_cache_1").
		Where("address = ?", obj.Token).
		First(&token).
		Error
	switch {
	case err == nil:
		// Nothing went wrong! Return the user what we found.
		return model.Token{token}, nil
	case errors.Is(err, gorm.ErrRecordNotFound):
		// Look up the token, and store it in the database.
		name, symbol, totalSupply, err := graphErc20.GetErc20Details(
			ctx,
			r.Geth,
			obj.Token,
		)
		if err != nil {
			return model.Token{}, fmt.Errorf("erc20 token %#v: %v", obj.Token, err)
		}
		err = r.DB.Exec(
			"SELECT erc20_insert_1(?, ?, ?, ?, ?)",
			obj.Token,
			name,
			symbol,
			totalSupply,
			obj.Decimals,
		).
			Error
		if err != nil {
			return model.Token{}, fmt.Errorf("insert erc20 %v: %v", obj.Token, err)
		}
		return model.Token{erc20.Erc20{
			Address:     obj.Token,
			Name:        name,
			Symbol:      symbol,
			TotalSupply: totalSupply,
			Decimals:    obj.Decimals,
		}}, nil
	default:
		return model.Token{}, err
	}
}

// Price is the resolver for the price field.
func (r *seawaterPoolResolver) Price(ctx context.Context, obj *seawater.Pool) (string, error) {
	// Get the last price item for the pool given.
	if obj == nil {
		return "", fmt.Errorf("empty pool")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		daily, _, _, err := MockPriceOverTime(31, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return "", err
		}
		return daily[0], nil
	}
	var result model.PriceResult
	err := r.DB.Table("seawater_latest_ticks_2").
		Where("pool = ?", obj.Token).
		First(&result).
		Error
	switch err {
	case gorm.ErrRecordNotFound:
		return "0", nil
	case nil:
		return result.Price(r.C.FusdcDecimals, int(obj.Decimals)), nil
	default:
		return "", err
	}
}

// PriceOverTime is the resolver for the priceOverTime field.
func (r *seawaterPoolResolver) PriceOverTime(ctx context.Context, obj *seawater.Pool) (price model.PriceOverTime, err error) {
	const (
		maxDays   = 31
		maxMonths = 12
	)
	if obj == nil {
		return price, fmt.Errorf("pool empty")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		daily, _, _, err := MockPriceOverTime(maxDays, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return price, err
		}
		monthly, _, _, err := MockPriceOverTime(maxMonths, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return price, err
		}
		return model.PriceOverTime{daily, monthly}, nil
	}
	var daily, monthly []model.PriceResult
	err = r.DB.Table("seawater_final_ticks_daily_2").
		Where("pool = ?", obj.Token).
		Limit(maxDays).
		Scan(&daily).
		Error
	if err != nil {
		return
	}
	err = r.DB.Table("seawater_final_ticks_monthly_3").
		Where("pool = ?", obj.Token).
		Limit(maxMonths).
		Scan(&monthly).
		Error
	if err != nil {
		return
	}
	for _, d := range daily {
		price.Daily = append(price.Daily, d.Price(r.C.FusdcDecimals, int(obj.Decimals)))
	}
	for _, m := range monthly {
		price.Monthly = append(price.Monthly, m.Price(r.C.FusdcDecimals, int(obj.Decimals)))
	}
	return price, nil
}

// VolumeOverTime is the resolver for the volumeOverTime field.
func (r *seawaterPoolResolver) VolumeOverTime(ctx context.Context, obj *seawater.Pool) (vol model.VolumeOverTime, err error) {
	const (
		maxDays   = 31
		maxMonths = 12
	)
	if obj == nil {
		return vol, fmt.Errorf("pool empty")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		daily, _, _, err := MockVolumeOverTime(31, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return vol, err
		}
		monthly, _, _, err := MockVolumeOverTime(31, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return vol, err
		}
		return model.VolumeOverTime{daily, monthly}, nil
	}
	var dailyResults, monthlyResults []struct {
		Token1Token    types.Address
		Token1Decimals int
		Timestamp      int
		// DailyTimestamp or MonthlyTimestamp
		IntervalTimestamp   time.Time
		FusdcValueUnscaled  types.UnscaledNumber
		Token1ValueUnscaled types.UnscaledNumber
	}
	err = r.DB.Table("seawater_pool_swap_volume_daily_1").
		Where("token1_token = ?", obj.Token).
		Limit(maxDays).Scan(&dailyResults).
		Error
	if err != nil {
		return
	}
	err = r.DB.Table("seawater_pool_swap_volume_monthly_1").
		Where("token1_token = ?", obj.Token).Limit(maxMonths).
		Scan(&monthlyResults).
		Error
	if err != nil {
		return
	}
	for _, d := range dailyResults {
		vol.Daily = append(vol.Daily, model.PairAmount{
			Timestamp: d.Timestamp,
			Fusdc: model.Amount{
				Token:         r.C.FusdcAddr,
				Decimals:      r.C.FusdcDecimals,
				Timestamp:     int(d.IntervalTimestamp.Unix()),
				ValueUnscaled: d.FusdcValueUnscaled,
			},
			Token1: model.Amount{
				Token:         d.Token1Token,
				Decimals:      d.Token1Decimals,
				Timestamp:     int(d.IntervalTimestamp.Unix()),
				ValueUnscaled: d.Token1ValueUnscaled,
			},
		})
	}
	for _, m := range monthlyResults {
		vol.Monthly = append(vol.Monthly, model.PairAmount{
			Timestamp: m.Timestamp,
			Fusdc: model.Amount{
				Token:         r.C.FusdcAddr,
				Decimals:      r.C.FusdcDecimals,
				Timestamp:     int(m.IntervalTimestamp.Unix()),
				ValueUnscaled: m.FusdcValueUnscaled,
			},
			Token1: model.Amount{
				Token:         m.Token1Token,
				Decimals:      m.Token1Decimals,
				Timestamp:     int(m.IntervalTimestamp.Unix()),
				ValueUnscaled: m.Token1ValueUnscaled,
			},
		})
	}
	return vol, nil
}

// LiquidityOverTime is the resolver for the liquidityOverTime field.
func (r *seawaterPoolResolver) LiquidityOverTime(ctx context.Context, obj *seawater.Pool) (liq model.LiquidityOverTime, err error) {
	if obj == nil {
		return liq, fmt.Errorf("pool empty")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		daily, _, _, err := MockVolumeOverTime(31, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return liq, err
		}
		monthly, _, _, err := MockVolumeOverTime(31, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return liq, err
		}
		return model.LiquidityOverTime{daily, monthly}, nil
	}
	return liq, nil // TODO
}

// TvlOverTime is the resolver for the tvlOverTime field.
func (r *seawaterPoolResolver) TvlOverTime(ctx context.Context, obj *seawater.Pool) (tvl model.TvlOverTime, err error) {
	if obj == nil {
		return tvl, fmt.Errorf("pool empty")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		daily, _, _, err := MockPriceOverTime(31, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return tvl, err
		}
		monthly, _, _, err := MockPriceOverTime(12, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return tvl, err
		}
		return model.TvlOverTime{daily, monthly}, nil
	}
	volumeOverTime, err := r.VolumeOverTime(ctx, obj)
	if err != nil {
		return
	}
	priceOverTime, err := r.PriceOverTime(ctx, obj)
	if err != nil {
		return
	}
	for i, v := range volumeOverTime.Daily {
		if len(priceOverTime.Daily) == i {
			break // Avoid a weird situation where the length doesn't add up.
		}
		var (
			dailyTvl string
			price    = priceOverTime.Daily[i]
		)
		dailyTvl, err = v.Token1.UsdValue(price, r.C.FusdcAddr)
		if err != nil {
			return
		}
		tvl.Daily = append(tvl.Daily, dailyTvl)
	}
	for i, v := range volumeOverTime.Monthly {
		if len(priceOverTime.Monthly) == i {
			break // Avoid a weird situation where the length doesn't add up.
		}
		var (
			monthlyTvl string
			price      = priceOverTime.Monthly[i]
		)
		monthlyTvl, err = v.Token1.UsdValue(price, r.C.FusdcAddr)
		if err != nil {
			return
		}
		tvl.Monthly = append(tvl.Monthly, monthlyTvl)
	}
	return tvl, nil
}

// YieldOverTime is the resolver for the yieldOverTime field.
func (r *seawaterPoolResolver) YieldOverTime(ctx context.Context, obj *seawater.Pool) (yield model.YieldOverTime, err error) {
	if obj == nil {
		return yield, fmt.Errorf("pool empty")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		daily, _, _, err := MockVolumeOverTime(31, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return yield, err
		}
		monthly, _, _, err := MockVolumeOverTime(12, r.C.FusdcAddr, obj.Token)
		return model.YieldOverTime{daily, monthly}, nil
	}
	return yield, nil // TODO
}

// EarnedFeesAprfusdc is the resolver for the earnedFeesAPRFUSDC field.
func (r *seawaterPoolResolver) EarnedFeesAprfusdc(ctx context.Context, obj *seawater.Pool) ([]string, error) {
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		return []string{"0", "0.15"}, nil
	}
	return nil, nil // TODO
}

// EarnedFeesAPRToken1 is the resolver for the earnedFeesAPRToken1 field.
func (r *seawaterPoolResolver) EarnedFeesAPRToken1(ctx context.Context, obj *seawater.Pool) ([]string, error) {
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		return []string{"0", "0.15"}, nil
	}
	return nil, nil // TODO
}

// LiquidityCampaigns is the resolver for the liquidityCampaigns field.
func (r *seawaterPoolResolver) LiquidityCampaigns(ctx context.Context, obj *seawater.Pool) ([]model.LiquidityCampaign, error) {
	panic(fmt.Errorf("not implemented: LiquidityCampaigns - liquidityCampaigns"))
}

// Positions is the resolver for the positions field.
func (r *seawaterPoolResolver) Positions(ctx context.Context, obj *seawater.Pool, first *int, after *int) (positions model.SeawaterPositionsGlobal, err error) {
	// If the user requested too large a limit, or they didn't supply a page size.
	if first == nil || *first > PoolPositionsPageSize {
		x := PoolPositionsPageSize
		first = &x
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		positions = model.SeawaterPositionsGlobal(MockGetPoolPositions(obj.Token))
		return
	}
	stmt := r.DB.Table("seawater_active_positions_2").
		Where("pool = ?", obj.Token).
		Limit(*first).
		Order("created_by desc")
	if after != nil {
		stmt = stmt.Where("created_by < ?", *after)
	}
	var pos []seawater.Position
	if err := stmt.Scan(&pos).Error; err != nil || pos == nil {
		return positions, err
	}
	p := obj.Token
	var to *int
	if l := len(pos); l > 0 {
		x := int(pos[l-1].CreatedBy.Unix())
		to = &x
	}
	positions = model.SeawaterPositionsGlobal(model.SeawaterPositions{
		From:      pos[0].Id,
		To:        to,
		Pool:      &p,
		Positions: pos,
	})
	return
}

// PositionsForUser is the resolver for the positionsForUser field.
func (r *seawaterPoolResolver) PositionsForUser(ctx context.Context, obj *seawater.Pool, wallet string, first *int, after *int) (positions model.SeawaterPositionsUser, err error) {
	w := types.AddressFromString(wallet)
	if obj == nil {
		return positions, fmt.Errorf("empty pool")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		positions = model.SeawaterPositionsUser(MockGetPoolPositions(w))
		return
	}
	err = r.DB.Table("seawater_active_positions_2").
		Where("pool = ? and owner = ?", obj.Token, wallet).
		Scan(&positions).
		Error
	return
}

// Liquidity is the resolver for the liquidity field.
func (r *seawaterPoolResolver) Liquidity(ctx context.Context, obj *seawater.Pool) (liquidity []model.SeawaterLiquidity, err error) {
	if obj == nil {
		return nil, fmt.Errorf("empty pool")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		liquidity = MockLiquidity(r.C.FusdcAddr, obj.Token)
		return
	}
	var groups []seawater.LiquidityGroup
	err = r.DB.Table("seawater_liquidity_groups_2").
		Where("pool = ?", obj.Token).
		Limit(LiquidityGroupsLimit).
		Scan(&groups).
		Error
	if err != nil {
		return nil, err
	}
	//10 ** decimals
	fusdcDecimals_ := new(big.Int).SetInt64(int64(r.C.FusdcDecimals))
	fusdcDecimals_.Exp(Ten, fusdcDecimals_, nil)
	fusdcDecimals := new(big.Rat).SetInt(fusdcDecimals_)
	liquidity = make([]model.SeawaterLiquidity, len(groups))
	for i, g := range groups {
		// Take the average of the two ticks. We can simply add
		// half the big tick (5000) to the lowest tick.
		tick := g.Tick.Big()
		tick.Add(tick, FiveThousand)
		ratio := math.GetSqrtRatioAtTick(tick)
		price := math.GetPriceAtSqrtRatio(ratio)
		// Use the price data to get the USD value of token1, and
		// add token0 to it, assuming it maintains peg. This is
		// the price of the asset.
		usdAmt1 := new(big.Rat).SetInt(g.CumulativeAmount1.Big())
		usdAmt1.Quo(usdAmt1, fusdcDecimals)
		usdAmt0 := new(big.Rat).SetInt(g.CumulativeAmount0.Big())
		d := new(big.Int).SetInt64(int64(g.Decimals))
		d.Exp(Ten, d, nil)
		usdAmt0.Quo(usdAmt0, new(big.Rat).SetInt(d))
		usdAmt0.Mul(usdAmt0, price)
		usdAmt0.Add(usdAmt0, usdAmt1)
		liquidity[i] = model.SeawaterLiquidity{
			ID:        "", // TODO
			TickLower: g.Tick.String(),
			TickUpper: g.NextTick.String(),
			Price:     price.FloatString(5),
			Liquidity: usdAmt0.FloatString(5),
		}
	}
	// Group all the positions data from the most recent snapshot,
	// and make sure it's sorted. Then send that to the UI.
	return
}

// Swaps is the resolver for the swaps field.
func (r *seawaterPoolResolver) Swaps(ctx context.Context, obj *seawater.Pool, first *int, after *int) (swaps model.SeawaterSwaps, err error) {
	if obj == nil {
		return swaps, fmt.Errorf("empty pool")
	}
	// If the user requested a nil limit, or they're too big.
	if first == nil || *first > SwapPositionsPageSize {
		fst := SwapPositionsPageSize
		first = &fst
	}
	if after == nil {
		aft := 0
		after = &aft
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		swaps = MockSwaps(r.C.FusdcAddr, 150, obj.Token)
		return
	}
	// DB.RAW doesn't support chaining
	err = r.DB.Raw(
		"SELECT * FROM seawater_swaps_pool_2(?, ?, ?, ?, ?)",
		r.C.FusdcAddr,
		r.C.FusdcDecimals,
		obj.Token,
		time.Unix(int64(*after), 0),
		*first,
	).
		Scan(&swaps.Swaps).
		Error
	swaps.Pool = &obj.Token
	return
}

// Amounts is the resolver for the amounts field.
func (r *seawaterPoolResolver) Amounts(ctx context.Context, obj *seawater.Pool) (amounts model.PairAmount, err error) {
	if obj == nil {
		return amounts, fmt.Errorf("empty pool")
	}
	// Sum the position snapshots for the pool address given.
	var sum seawater.SnapshotPositionsLatestDecimalsGroup
	err = r.DB.
		Table("snapshot_positions_latest_decimals_grouped_1").
		Where("pool = ?", obj.Token).
		First(&sum).
		Error
	if err != nil {
		return
	}
	ts := int(time.Now().Unix())
	amounts = model.PairAmount{
		Timestamp: ts,
		Fusdc: model.Amount{
			Token:         r.C.FusdcAddr,
			Decimals:      r.C.FusdcDecimals,
			Timestamp:     ts,
			ValueUnscaled: sum.CumulativeAmount0,
		},
		Token1: model.Amount{
			Token:         obj.Token,
			Decimals:      int(sum.Decimals),
			Timestamp:     ts,
			ValueUnscaled: sum.CumulativeAmount1,
		},
	}
	return
}

// Config is the resolver for the config field.
func (r *seawaterPoolResolver) Config(ctx context.Context, obj *seawater.Pool) (m model.SeawaterConfig, err error) {
	if obj == nil {
		return m, fmt.Errorf("empty pool")
	}
	c, ok := r.PoolsConfig[obj.Token]
	if !ok {
		// Return the default pool configuration.
		return model.SeawaterConfig{obj.Token, config.DefaultPoolConfiguration}, nil
	}
	return model.SeawaterConfig{obj.Token, c}, nil
}

// Served is the resolver for the served field.
func (r *seawaterPositionResolver) Served(ctx context.Context, obj *seawater.Position) (model.Served, error) {
	return model.Served{
		Timestamp: int(time.Now().Unix()),
	}, nil
}

// ID is the resolver for the id field.
func (r *seawaterPositionResolver) ID(ctx context.Context, obj *seawater.Position) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty position")
	}
	return fmt.Sprintf("pos:%v:%v", obj.Pool, obj.Id), nil
}

// Created is the resolver for the created field.
func (r *seawaterPositionResolver) Created(ctx context.Context, obj *seawater.Position) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("no position obj")
	}
	var pos seawater.Position
	err := r.DB.
		Table("events_seawater_mintposition").
		Where("pos_id = ?", obj.Id).
		Scan(&pos).
		Error
	if err != nil {
		return 0, nil
	}
	ts := pos.CreatedBy.Unix()
	return int(ts), nil
}

// PositionID is the resolver for the positionId field.
func (r *seawaterPositionResolver) PositionID(ctx context.Context, obj *seawater.Position) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("no position obj")
	}
	return obj.Id, nil
}

// Owner is the resolver for the owner field.
func (r *seawaterPositionResolver) Owner(ctx context.Context, obj *seawater.Position) (model.Wallet, error) {
	if obj == nil {
		return model.Wallet{}, fmt.Errorf("no position obj")
	}
	wallet, err := r.Query().GetWallet(ctx, obj.Owner.String())
	if err != nil {
		return model.Wallet{}, err
	}
	return *wallet, nil
}

// Pool is the resolver for the pool field.
func (r *seawaterPositionResolver) Pool(ctx context.Context, obj *seawater.Position) (pool seawater.Pool, err error) {
	if obj == nil {
		return seawater.Pool{}, fmt.Errorf("no position obj")
	}
	err = r.DB.Table("events_seawater_newpool").
		Where("token = ?", obj.Pool).
		Scan(&pool).Error
	return
}

// Lower is the resolver for the lower field.
func (r *seawaterPositionResolver) Lower(ctx context.Context, obj *seawater.Position) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("no position obj")
	}
	return int(obj.Lower.Int64()), nil
}

// Upper is the resolver for the upper field.
func (r *seawaterPositionResolver) Upper(ctx context.Context, obj *seawater.Position) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("no position obj")
	}
	return int(obj.Upper.Int64()), nil
}

// Liquidity is the resolver for the liquidity field.
func (r *seawaterPositionResolver) Liquidity(ctx context.Context, obj *seawater.Position) (model.PairAmount, error) {
	if obj == nil {
		return model.PairAmount{}, fmt.Errorf("no position obj")
	}
	var pool seawater.Pool
	err := r.DB.Table("events_seawater_newpool").
		Select("decimals").
		Where("token = ?", obj.Pool).
		First(&pool).
		Error
	if err != nil {
		return model.PairAmount{}, fmt.Errorf("finding new pool: %v", err)
	}
	var res seawater.PositionSnapshot
	err = r.DB.Table("snapshot_positions_latest_1").
		Where("pos_id = ?", obj.Id).
		First(&res).
		Error
	ts := int(res.UpdatedBy.Unix())
	switch {
	case errors.Is(err, gorm.ErrRecordNotFound):
		// We didn't find a pair amount! Return nothing.
		return model.PairAmount{
			Timestamp: ts,
			Fusdc: model.Amount{
				Token:         r.C.FusdcAddr,
				Decimals:      r.C.FusdcDecimals,
				Timestamp:     ts,
				ValueUnscaled: types.EmptyUnscaledNumber(),
			},
			Token1: model.Amount{
				Token:         obj.Pool,
				Decimals:      int(pool.Decimals),
				Timestamp:     ts,
				ValueUnscaled: types.EmptyUnscaledNumber(),
			},
		}, nil
	case err == nil:
		// Do nothing. The good path!
	default:
		return model.PairAmount{}, fmt.Errorf("position id: %#v: %v", obj.Id, err)
	}
	return model.PairAmount{
		Timestamp: ts,
		Fusdc: model.Amount{
			Token:         r.C.FusdcAddr,
			Decimals:      r.C.FusdcDecimals,
			Timestamp:     ts,
			ValueUnscaled: res.Amount1,
		},
		Token1: model.Amount{
			Token:         obj.Pool,
			Decimals:      int(pool.Decimals),
			Timestamp:     ts,
			ValueUnscaled: res.Amount0,
		},
	}, nil
}

// ID is the resolver for the id field.
func (r *seawaterPositionsGlobalResolver) ID(ctx context.Context, obj *model.SeawaterPositionsGlobal) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty positions")
	}
	var to int
	if obj.To != nil {
		to = *obj.To
	}
	return fmt.Sprintf("posglobal:%v:%v", obj.From, to), nil
}

// Sum is the resolver for the sum field.
func (r *seawaterPositionsGlobalResolver) Sum(ctx context.Context, obj *model.SeawaterPositionsGlobal) (amounts []model.PairAmount, err error) {
	if obj == nil {
		return nil, fmt.Errorf("empty positions")
	}
	// Try to figure out whether we're servicing a per-wallet request, or a per-pool request.
	var results []seawater.SnapshotPositionsLatestDecimalsGroup
	stmt := r.DB
	switch {
	case obj.Pool != nil:
		stmt = stmt.
			Table("snapshot_positions_latest_decimals_grouped_1").
			Where("pool = ?", obj.Pool)
	case obj.Wallet != nil:
		stmt = stmt.
			Raw(
				"SELECT * FROM snapshot_positions_latest_decimals_grouped_user_1(?)",
				obj.Wallet,
			)
	default:
		return nil, nil // Assume the query above didn't find any responses.
	}
	if err := stmt.Scan(&results).Error; err != nil {
		return nil, err
	}
	amounts = make([]model.PairAmount, len(results))
	now := int(time.Now().Unix())
	for i, res := range results {
		amounts[i] = model.PairAmount{
			Timestamp: now,
			Fusdc: model.Amount{
				Token:         r.C.FusdcAddr,
				Decimals:      r.C.FusdcDecimals,
				Timestamp:     now,
				ValueUnscaled: res.CumulativeAmount0,
			},
			Token1: model.Amount{
				Token:         res.Pool,
				Decimals:      int(res.Decimals),
				Timestamp:     now,
				ValueUnscaled: res.CumulativeAmount1,
			},
		}
	}
	return
}

// Next is the resolver for the next field.
func (r *seawaterPositionsGlobalResolver) Next(ctx context.Context, obj *model.SeawaterPositionsGlobal, first *int) (model.SeawaterPositionsGlobal, error) {
	if obj == nil {
		return model.SeawaterPositionsGlobal{}, fmt.Errorf("empty positions")
	}
	if first == nil || *first > PoolPositionsPageSize {
		x := PoolPositionsPageSize
		first = &x
	}
	// Check if we're able to continue, if to is set to anything other than nil.
	if obj.To == nil {
		// Looks like we can't continue! Return current positions obj.
		return *obj, nil
	}
	to := time.Unix(int64(*obj.To), 0)
	// Start to construct a statement based on whether internally a
	// wallet, or a pool, was used.
	stmt := r.DB.Table("seawater_active_positions_2").
		Where("created_by < ?", to).
		Limit(*first).
		Order("created_by desc")
	switch {
	case obj.Wallet != nil:
		// If a wallet was used, we filter on the wallet.
		stmt = stmt.Where("owner = ?", *obj.Wallet)
	case obj.Pool != nil:
		// Pool was used! Filtering there.
		stmt = stmt.Where("pool = ?", obj.Pool)
	default:
		return model.SeawaterPositionsGlobal{}, fmt.Errorf("unimplemented positions pagination behaviour")
	}
	var pos []seawater.Position
	if err := stmt.Scan(&pos).Error; err != nil {
		return model.SeawaterPositionsGlobal{}, err
	}
	var newTo *int
	if l := len(pos); l > 0 {
		x := int(pos[l-1].CreatedBy.Unix())
		newTo = &x
	}
	return model.SeawaterPositionsGlobal{
		From:      *obj.To,
		To:        newTo,
		Pool:      obj.Pool,
		Wallet:    obj.Wallet,
		Positions: pos,
	}, nil
}

// ID is the resolver for the id field.
func (r *seawaterPositionsUserResolver) ID(ctx context.Context, obj *model.SeawaterPositionsUser) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty positions")
	}
	var to int
	if obj.To != nil {
		to = *obj.To
	}
	return fmt.Sprintf("posuser:%v:%v", obj.From, to), nil
}

// Sum is the resolver for the sum field.
func (r *seawaterPositionsUserResolver) Sum(ctx context.Context, obj *model.SeawaterPositionsUser) (amounts []model.PairAmount, err error) {
	if obj == nil {
		return nil, fmt.Errorf("empty positions")
	}
	// Try to figure out whether we're servicing a per-wallet request, or a per-pool request.
	var results []seawater.SnapshotPositionsLatestDecimalsGroup
	stmt := r.DB
	switch {
	case obj.Pool != nil:
		stmt = stmt.
			Table("snapshot_positions_latest_decimals_grouped_1").
			Where("pool = ?", obj.Pool)
	case obj.Wallet != nil:
		stmt = stmt.
			Raw(
				"SELECT * FROM snapshot_positions_latest_decimals_grouped_user_1(?)",
				obj.Wallet,
			)
	default:
		return nil, nil // Assume the query above didn't find any responses.
	}
	if err := stmt.Scan(&results).Error; err != nil {
		return nil, err
	}
	amounts = make([]model.PairAmount, len(results))
	now := int(time.Now().Unix())
	for i, res := range results {
		amounts[i] = model.PairAmount{
			Timestamp: now,
			Fusdc: model.Amount{
				Token:         r.C.FusdcAddr,
				Decimals:      r.C.FusdcDecimals,
				Timestamp:     now,
				ValueUnscaled: res.CumulativeAmount0,
			},
			Token1: model.Amount{
				Token:         res.Pool,
				Decimals:      int(res.Decimals),
				Timestamp:     now,
				ValueUnscaled: res.CumulativeAmount1,
			},
		}
	}
	return
}

// Next is the resolver for the next field.
func (r *seawaterPositionsUserResolver) Next(ctx context.Context, obj *model.SeawaterPositionsUser, first *int) (model.SeawaterPositionsUser, error) {
	if obj == nil {
		return model.SeawaterPositionsUser{}, fmt.Errorf("empty positions")
	}
	if first == nil || *first > PoolPositionsPageSize {
		x := PoolPositionsPageSize
		first = &x
	}
	// Check if we're able to continue, if to is set to anything other than nil.
	if obj.To == nil {
		// Looks like we can't continue! Return current positions obj.
		return *obj, nil
	}
	to := time.Unix(int64(*obj.To), 0)
	// Start to construct a statement based on whether internally a
	// wallet, or a pool, was used.
	stmt := r.DB.Table("seawater_active_positions_2").
		Where("created_by < ?", to).
		Limit(*first).
		Order("created_by desc")
	switch {
	case obj.Wallet != nil:
		// If a wallet was used, we filter on the wallet.
		stmt = stmt.Where("owner = ?", *obj.Wallet)
	case obj.Pool != nil:
		// Pool was used! Filtering there.
		stmt = stmt.Where("pool = ?", obj.Pool)
	default:
		return model.SeawaterPositionsUser{}, fmt.Errorf("unimplemented positions pagination behaviour")
	}
	var pos []seawater.Position
	if err := stmt.Scan(&pos).Error; err != nil {
		return model.SeawaterPositionsUser{}, err
	}
	var newTo *int
	if l := len(pos); l > 0 {
		x := int(pos[l-1].CreatedBy.Unix())
		newTo = &x
	}
	return model.SeawaterPositionsUser{
		From:      *obj.To,
		To:        newTo,
		Pool:      obj.Pool,
		Wallet:    obj.Wallet,
		Positions: pos,
	}, nil
}

// Served is the resolver for the served field.
func (r *seawaterSwapResolver) Served(ctx context.Context, obj *model.SeawaterSwap) (model.Served, error) {
	return model.Served{
		Timestamp: int(time.Now().Unix()),
	}, nil
}

// Timestamp is the resolver for the timestamp field.
func (r *seawaterSwapResolver) Timestamp(ctx context.Context, obj *model.SeawaterSwap) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("empty swap")
	}
	return int(obj.CreatedBy.Unix()), nil
}

// Pool is the resolver for the pool field.
func (r *seawaterSwapResolver) Pool(ctx context.Context, obj *model.SeawaterSwap) (seawater.Pool, error) {
	var token string
	if obj.TokenIn == r.C.FusdcAddr {
		token = obj.TokenOut.String()
	} else {
		token = obj.TokenIn.String()
	}
	pool, err := r.Query().GetPool(ctx, token)
	if err != nil {
		return seawater.Pool{}, err
	}
	return *pool, nil
}

// TransactionHash is the resolver for the transactionHash field.
func (r *seawaterSwapResolver) TransactionHash(ctx context.Context, obj *model.SeawaterSwap) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty swap")
	}
	return obj.TransactionHash.String(), nil
}

// Sender is the resolver for the sender field.
func (r *seawaterSwapResolver) Sender(ctx context.Context, obj *model.SeawaterSwap) (model.Wallet, error) {
	if obj == nil {
		return model.Wallet{}, fmt.Errorf("empty swap")
	}
	wallet, err := r.Query().GetWallet(ctx, obj.Sender.String())
	if err != nil {
		return model.Wallet{}, err
	}
	return *wallet, nil
}

// AmountIn is the resolver for the amountIn field.
func (r *seawaterSwapResolver) AmountIn(ctx context.Context, obj *model.SeawaterSwap) (model.Amount, error) {
	if obj == nil {
		return model.Amount{}, fmt.Errorf("empty swap")
	}
	return model.Amount{
		Token:         obj.TokenIn,
		Decimals:      obj.TokenInDecimals,
		Timestamp:     int(obj.CreatedBy.Unix()),
		ValueUnscaled: obj.AmountIn,
	}, nil
}

// AmountOut is the resolver for the amountOut field.
func (r *seawaterSwapResolver) AmountOut(ctx context.Context, obj *model.SeawaterSwap) (model.Amount, error) {
	if obj == nil {
		return model.Amount{}, fmt.Errorf("empty swap")
	}
	return model.Amount{
		Token:         obj.TokenOut,
		Decimals:      obj.TokenOutDecimals,
		Timestamp:     int(obj.CreatedBy.Unix()),
		ValueUnscaled: obj.AmountOut,
	}, nil
}

// Sum is the resolver for the sum field.
func (r *seawaterSwapsResolver) Sum(ctx context.Context, obj *model.SeawaterSwaps) (amounts []model.PairAmount, err error) {
	if obj == nil {
		return nil, fmt.Errorf("empty swaps")
	}
	// Try to figure out whether we're servicing a per-wallet request, or a per-pool request.
	var results []seawater.SwapsDecimalsGroup
	stmt := r.DB
	switch {
	case obj.Pool != nil:
		stmt = stmt.
			Raw(
				"SELECT * FROM swaps_decimals_pool_group_1(?,?,?)",
				r.C.FusdcAddr,
				r.C.FusdcDecimals,
				*obj.Pool,
			)
	case obj.Wallet != nil:
		stmt = stmt.
			Raw(
				"SELECT * FROM swaps_decimals_user_group_1(?,?,?)",
				r.C.FusdcAddr,
				r.C.FusdcDecimals,
				*obj.Wallet,
			)
	default:
		return nil, nil // Assume the query above didn't find any responses.
	}
	if err := stmt.Scan(&results).Error; err != nil {
		return nil, err
	}
	amounts = make([]model.PairAmount, len(results))
	now := int(time.Now().Unix())
	for i, res := range results {
		amounts[i] = model.PairAmount{
			Timestamp: now,
			Fusdc: model.Amount{
				Token:         r.C.FusdcAddr,
				Decimals:      r.C.FusdcDecimals,
				Timestamp:     now,
				ValueUnscaled: res.CumulativeAmount0,
			},
			Token1: model.Amount{
				Token:         res.Pool,
				Decimals:      int(res.Decimals),
				Timestamp:     now,
				ValueUnscaled: res.CumulativeAmount1,
			},
		}
	}
	return
}

// Next is the resolver for the next field.
func (r *seawaterSwapsResolver) Next(ctx context.Context, obj *model.SeawaterSwaps, first *int) (model.SeawaterSwaps, error) {
	panic(fmt.Errorf("not implemented: Next - next"))
}

// ID is the resolver for the id field.
func (r *tokenResolver) ID(ctx context.Context, obj *model.Token) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty token")
	}
	return fmt.Sprintf("token:%v", obj.Address), nil
}

// Address is the resolver for the address field.
func (r *tokenResolver) Address(ctx context.Context, obj *model.Token) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty token")
	}
	return obj.Address.String(), nil
}

// Image is the resolver for the image field.
func (r *tokenResolver) Image(ctx context.Context, obj *model.Token) (string, error) {
	panic(fmt.Errorf("not implemented: Image - image"))
}

// TotalSupply is the resolver for the totalSupply field.
func (r *tokenResolver) TotalSupply(ctx context.Context, obj *model.Token) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty token")
	}
	return obj.TotalSupply.String(), nil
}

// ID is the resolver for the id field.
func (r *walletResolver) ID(ctx context.Context, obj *model.Wallet) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty token")
	}
	return fmt.Sprintf("wallet:%v", obj.Address), nil
}

// Address is the resolver for the address field.
func (r *walletResolver) Address(ctx context.Context, obj *model.Wallet) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("no token")
	}
	return obj.Address.String(), nil
}

// Balances is the resolver for the balances field.
func (r *walletResolver) Balances(ctx context.Context, obj *model.Wallet) ([]model.Amount, error) {
	panic(fmt.Errorf("not implemented: Balances - balances"))
}

// Positions is the resolver for the positions field.
func (r *walletResolver) Positions(ctx context.Context, obj *model.Wallet, first *int, after *int) (positions model.SeawaterPositionsUser, err error) {
	if obj == nil {
		return positions, fmt.Errorf("empty wallet")
	}
	// Prevent nil firsts, or past the limit.
	if first == nil || *first > PoolPositionsPageSize {
		x := PoolPositionsPageSize
		first = &x
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		positions = model.SeawaterPositionsUser(
			MockGetPoolPositions("0x65dfe41220c438bf069bbce9eb66b087fe65db36"),
		)
		return
	}
	stmt := r.DB.Table("seawater_active_positions_2").
		Where("owner = ?", obj.Address).
		Limit(*first).
		Order("created_by desc")
	if after != nil {
		stmt = stmt.Where("pos_id > ?", *after)
	}
	var pos []seawater.Position
	if err := stmt.Scan(&pos).Error; err != nil || pos == nil {
		return positions, err
	}
	w := obj.Address
	var to *int
	if l := len(pos); l > 0 {
		x := int(pos[l-1].CreatedBy.Unix())
		to = &x
	}
	positions = model.SeawaterPositionsUser(model.SeawaterPositions{
		From:      *first,
		To:        to,
		Wallet:    &w,
		Positions: pos,
	})
	return
}

// Amount returns AmountResolver implementation.
func (r *Resolver) Amount() AmountResolver { return &amountResolver{r} }

// LiquidityCampaign returns LiquidityCampaignResolver implementation.
func (r *Resolver) LiquidityCampaign() LiquidityCampaignResolver {
	return &liquidityCampaignResolver{r}
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// SeawaterConfig returns SeawaterConfigResolver implementation.
func (r *Resolver) SeawaterConfig() SeawaterConfigResolver { return &seawaterConfigResolver{r} }

// SeawaterLiquidity returns SeawaterLiquidityResolver implementation.
func (r *Resolver) SeawaterLiquidity() SeawaterLiquidityResolver {
	return &seawaterLiquidityResolver{r}
}

// SeawaterPool returns SeawaterPoolResolver implementation.
func (r *Resolver) SeawaterPool() SeawaterPoolResolver { return &seawaterPoolResolver{r} }

// SeawaterPosition returns SeawaterPositionResolver implementation.
func (r *Resolver) SeawaterPosition() SeawaterPositionResolver { return &seawaterPositionResolver{r} }

// SeawaterPositionsGlobal returns SeawaterPositionsGlobalResolver implementation.
func (r *Resolver) SeawaterPositionsGlobal() SeawaterPositionsGlobalResolver {
	return &seawaterPositionsGlobalResolver{r}
}

// SeawaterPositionsUser returns SeawaterPositionsUserResolver implementation.
func (r *Resolver) SeawaterPositionsUser() SeawaterPositionsUserResolver {
	return &seawaterPositionsUserResolver{r}
}

// SeawaterSwap returns SeawaterSwapResolver implementation.
func (r *Resolver) SeawaterSwap() SeawaterSwapResolver { return &seawaterSwapResolver{r} }

// SeawaterSwaps returns SeawaterSwapsResolver implementation.
func (r *Resolver) SeawaterSwaps() SeawaterSwapsResolver { return &seawaterSwapsResolver{r} }

// Token returns TokenResolver implementation.
func (r *Resolver) Token() TokenResolver { return &tokenResolver{r} }

// Wallet returns WalletResolver implementation.
func (r *Resolver) Wallet() WalletResolver { return &walletResolver{r} }

type amountResolver struct{ *Resolver }
type liquidityCampaignResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type seawaterConfigResolver struct{ *Resolver }
type seawaterLiquidityResolver struct{ *Resolver }
type seawaterPoolResolver struct{ *Resolver }
type seawaterPositionResolver struct{ *Resolver }
type seawaterPositionsGlobalResolver struct{ *Resolver }
type seawaterPositionsUserResolver struct{ *Resolver }
type seawaterSwapResolver struct{ *Resolver }
type seawaterSwapsResolver struct{ *Resolver }
type tokenResolver struct{ *Resolver }
type walletResolver struct{ *Resolver }
