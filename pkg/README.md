
# Superposition contracts

## Security

[Security instructions](https://github.com/fluidity-money/long.so/blob/development/SECURITY)

## Contributors

[Contributors](https://github.com/fluidity-money/long.so/blob/development/AUTHORS.md)

## Longtail

Longtail is Arbitrum's cheapest and most rewarding AMM.

### Deployments

#### Superposition Testnet

[Superposition RPC](https://docs.superposition.so/superposition-testnet/network-details)

##### AMM contract deployments

|         Deployment name        |              Deployment address            |
|--------------------------------|--------------------------------------------|
| Longtail AMM                   | 0xE13Fec14aBFbAa5b185cFb46670A56BF072E13b1 |
| Longtail NFT manager           | 0x1260F0E48AA5A195C811B5E7B1DFac1E9AD8debB |
| Permit2 router                 | 0x2246431582087b930F2CE561c34deb8E7e5c44bE |
| Swaps implementation           | 0xf13b986d6e71b89a0c1823400b66a6854ddc6a4d |
| Swaps permit2 implementation   | 0xefa6fa55fdf45af095fd4c1069060783f8fae323 |
| Quotes implementation          | 0xd73a30f58526d543e814b4267bdf681be654f839 |
| Positions implementation       | 0x29603b0bdb884f68fa24fd1c453ccdbb4860ce28 |
| Update position implementation | 0x41ee808f99dddb9b2e5e6fd0d80624455104d3f5 |
| Admin implementation           | 0x9c9e3ead905fe5407feffb22d74fe68f0af98a45 |


##### Useful testing token deployments

|       Deployment name     |              Deployment address            |
|---------------------------|--------------------------------------------|
| fUSDC                     | 0xA8EA92c819463EFbEdDFB670FEfC881A480f0115 |
| WETH                      | 0xde104342B32BCa03ec995f999181f7Cf1fFc04d7 |
| USDC                      | 0x6437fdc89cED41941b97A9f1f8992D88718C81c5 |
| WSPN                      | 0x22b9fa698b68bBA071B513959794E9a47d19214c |
| CATBUX                    | 0x36c116a8851869cf8a99b3Bda0Fad42453D32B99 |

### Errors

Currently, to save on space, errors generated by the contract are terse. Decode the hex to
the appropriate error in this table:

| No |  Hex |                                   Explanation                                           |
|----|------|-----------------------------------------------------------------------------------------|
| 0  | 0x00 | Denominator is 0                                                                        |
| 1  | 0x01 | Result is U256::MAX                                                                     |
| 2  | 0x02 | Sqrt price is 0                                                                         |
| 3  | 0x03 | Sqrt price is less than or equal to quotient                                            |
| 4  | 0x04 | Can not get most significant bit or least significant bit on zero value                 |
| 5  | 0x05 | Liquidity is 0                                                                          |
| 6  | 0x06 | require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);    |
| 7  | 0x07 | Denominator is less than or equal to prod_1                                             |
| 8  | 0x08 | Liquidity Sub                                                                           |
| 9  | 0x09 | Liquidity Add                                                                           |
| 10 | 0x0a | The given tick must be less than, or equal to, the maximum tick                         |
| 11 | 0x0b | Second inequality must be < because the price can never reach the price at the max tick |
| 12 | 0x0c | Overflow when casting to U160                                                           |
| 13 | 0x0d | Liquidity higher than max                                                               |
| 14 | 0x0e | Fee growth sub overflow                                                                 |
| 15 | 0x0f | ERC20 call reverted                                                                     |
| 16 | 0x10 | ERC20 call reverted with no data                                                        |
| 17 | 0x11 | Pool is already initialised                                                             |
| 18 | 0x12 | Contract is already initialised                                                         |
| 19 | 0x13 | Price limit too high                                                                    |
| 20 | 0x14 | Price limit too low                                                                     |
| 21 | 0x15 | Checked abs called on an unexpected positive number                                     |
| 22 | 0x16 | Checked abs called on an unexpected negative number                                     |
| 23 | 0x17 | Checked abs called on uint.min                                                          |
| 24 | 0x18 | Fee result too high                                                                     |
| 25 | 0x19 | Swap result too high                                                                    |
| 26 | 0x1a | Internal swap amounts not matched                                                       |
| 27 | 0x1b | Internal swap result was positive                                                       |
| 28 | 0x1c | Minimum out not reached                                                                 |
| 29 | 0x1d | Only the position owner can use this                                                    |
| 30 | 0x1e | Only the NFT manager can use this                                                       |
| 31 | 0x1f | Only the Seawater admin can use this                                                    |
| 32 | 0x20 | Operation unavailable when the pool is disabled                                         |
| 33 | 0x21 | Invalid tick spacing                                                                    |
| 34 | 0x22 | Swap result too low                                                                     |
| 35 | 0x23 | Liquidity too low or high to be a int128                                                |
| 36 | 0x24 | Invalid tick                                                                            |
| 37 | 0x25 | Pool enabled when it should be disabled for this action                                 |
| 38 | 0x26 | Position is empty when it shouldn't be                                                  |
| 39 | 0x27 | Liquidity that was almost taken was too low when it didn't need to be                   |
| 40 | 0x28 | Fee growth that tried to be calculated was bad internally for a tick                    |

If more bytes are in the error, then the issue was produced by the ERC20 token. Convert
any error types to their selector form to see.

### Access graph

A publicly available graph for Longtail is available. It includes
documentation. [https://testnet-graph.long.so](https://testnet-graph.long.so).

### Building

Longtail ("Seawater") is a diamond-like contract, with the frontend to access
the Stylus diamond facets implemented in Solidity. So, Stylus is needed
with Rust for the implementation contracts, and Foundry is needed
to compile the contract.

To save on contract size, and to reduce gas overhead, this contract stores
the addresses of the swap router, and the admin address, at compile-time.

So these variables must set at compile-time, like so:

#### Build variables

|           Name              |                   Description                 |
|-----------------------------|---------------------------------------------- |
| `FLU_SEAWATER_PERMIT2_ADDR` | Uniswap Permit2 router                        |
| `FLU_SEAWATER_FUSDC_ADDR`   | USDC Super Asset to route every trade through |

#### Build dependencies

|           Name          |                        Source                        |
|-------------------------|------------------------------------------------------|
| Rust (nightly version)  | [Installer](https://rustup.rs/)                      |
| Cargo Stylus subcommand | [Repo](https://github.com/OffchainLabs/cargo-stylus) |
| Foundry                 | [Installer](https://getfoundry.sh/)                  |
| Make                    | `build-essentials` if you're on Linux                |

#### Build process

	make build

### Testing

Testing is done with via a hosted test using cargo features with the
testing flag. `tests.sh` is provided to run both test suites.

End to end testing is currently unavailable due to issues with the deployment
toolchain.

#### Testing process

	./tests.sh

#### Cargo test tracing

Some of the cargo tests have optional logging, which might help with debugging. To see
these logs, enable the `testing-dbg-<test>`
feature and run the tests without capturing stdout, ie `cargo test
--features=testing,testing-dbg-erc20 -- --nocapture`.

Testing tools are available with the `with_storage` macro, which lets you set slots and
maximum balances for ERC20 transfers. Reproducing on-chain transactions is possible by
using a tracer on the chain the transaciton took place, then examining the storage slots
that were accessed (perhaps by looking at `SLOAD`s), and setting it explicitly with the
macro.

### Deployment

You can deploy the contracts using the `deploy.sh` script.

#### Test deployments

Deployments on a local node can be done with `./test-deploy.sh` for simplicity.

#### Deployment variables

|           Name            |                                             Description                                             |
|---------------------------|-----------------------------------------------------------------------------------------------------|
| `SEAWATER_PROXY_ADMIN`    | Address that's permitted to administrate the code, including deploying updates, and creating pools. |
| `STYLUS_ENDPOINT`         | URL to access the Stylus node.                                                                      |
| `STYLUS_PRIVATE_KEY`      | Private key to use for deployment.                                                                  |
| `FLU_SEAWATER_FUSDC_ADDR` | Super USDC address to use as the base asset for each pool.                                          |

## Leo

Leo (also known as the Seawater Rewards Manager) is a contract that allows users to vest their LP
tokens in the form of a transferFrom using the NFTManager contract. Leo remembers
who owns the LP NFTs it has, and does things like collect fees on the behalf of the owner,
and knows to do so when determining "real yield" mixed with fees earned for LPing.
