package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"fmt"
	"log/slog"
	"strings"
	"time"

	"github.com/fluidity-money/long.so/cmd/faucet.superposition/lib/faucet"
	"github.com/fluidity-money/long.so/lib/features"
)

// RequestTokens is the resolver for the requestTokens field.
func (r *mutationResolver) RequestTokens(ctx context.Context, wallet_ string, turnstileToken string) (string, error) {
	wallet := strings.ToLower(wallet_)
	// Get the user's IP address to prevent them from spamming this
	// incase our rate limiting is skipped somehow (it's good to be cautious.)
	ipAddrs, _ := ctx.Value("X-Forwarded-For").(string)
	ipAddrsSplit := strings.Split(ipAddrs, ",")
	if len(ipAddrsSplit) == 0 {
		slog.Error("something is wrong with the middleware, refusing this request",
			"wallet", wallet,
		)
		return "", fmt.Errorf("internal error")
	}
	ipAddr := ipAddrsSplit[0]
	// First, verify the user's request via Cloudflare.
	verifiedTurnstile, err := VerifyTurnstile(r.TurnstileSecret, turnstileToken)
	if err != nil {
		slog.Error("failed to verify turnstile",
			"ip addr", ipAddr,
			"submitted query", wallet,
			"err", err,
		)
		return "", fmt.Errorf("failed to verify")
	}
	if !verifiedTurnstile {
		slog.Error("bad turnstile token!",
			"ip addr", ipAddr,
			"submitted query", wallet,
		)
		return "", fmt.Errorf("bad turnstile")
	}
	// Check if the faucet is actually enabled with a feature.
	if enabled := r.F.Is(features.FeatureFaucetEnabled); !enabled {
		slog.Error("faucet is currently disabled",
			"ip addr", ipAddr,
			"submitted query", wallet,
		)
		return "", fmt.Errorf("faucet disabled")
	}
	slog.Debug("handled request to send some tokens",
		"ip addr", ipAddr,
		"wallet", wallet,
	)
	// Make sure the wallet they've given is actually valid.
	if validWallet := IsValidWallet(wallet); !validWallet {
		slog.Error("bad wallet request",
			"ip addr", ipAddr,
			"submitted query", wallet,
		)
		return "", fmt.Errorf("bad wallet")
	}
	// Check if they're a staker for their bonus.
	isFlyStaker, err := IsUserStaker(wallet)
	if err != nil {
		slog.Error("error requesting whether the user is a staker",
			"ip addr", ipAddr,
			"submitted wallet", wallet,
		)
		return "", fmt.Errorf("error requesting: %v", err)
	}
	// If the user is not a fly staker, kick them out if this feature is enabled.
	if r.F.Is(features.FeatureFaucetStakersOnly) && !isFlyStaker {
		slog.Error("non staker requested spn airdrop",
			"ip addr", ipAddr,
			"submitted wallet", wallet,
		)
		return "", fmt.Errorf("not staker")
	}
	// Check if the user is within the window to make requests.
	// Checks if there are any rows that exceed a 5 hour addition to
	// the updated time to see if they're within that window.
	attempts, err := r.DB.
		Raw("SELECT 1 FROM faucet_requests WHERE (addr = ? OR ip_addr = ?) AND updated_by + INTERVAL '5 hours' > CURRENT_TIMESTAMP", wallet, ipAddr).
		Rows()
	if err != nil {
		slog.Error("failure to get attempts",
			"ip addr", ipAddr,
			"submitted wallet", wallet,
			"err", err,
		)
		return "", fmt.Errorf("internal error")
	}
	defer attempts.Close()
	if attempts.Next() { // If this happens, then we got a row that's bad.
		slog.Error("too many requests made",
			"ip addr", ipAddr,
			"submitted wallet", wallet,
			"err", err,
		)
		return "", fmt.Errorf("too many requests")
	}
	// Mark that the request was serviced so we don't double up.
	err = r.DB.
		Table("faucet_requests").
		Create(faucet.FaucetRequest{
			Addr:        wallet,
			IpAddr:      ipAddr,
			CreatedBy:   time.Now(),
			UpdatedBy:   time.Now(),
			WasSent:     false,
			IsFlyStaker: isFlyStaker,
		}).
		Error
	if err != nil {
		slog.Error("failed to upsert a faucet request",
			"ip addr", ipAddr,
			"submitted wallet", wallet,
			"err", err,
		)
		return "", fmt.Errorf("internal error")
	}
	return "", nil
}

// Healthcheck is the resolver for the healthcheck field.
func (r *queryResolver) Healthcheck(ctx context.Context) (int, error) {
	return 0, nil // TODO
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
const TimeToLive = 10 * time.Second
